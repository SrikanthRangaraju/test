package stats;

import java.io.*;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.nio.file.Files;
import java.util.*;
import java.util.stream.Collectors;

public class CSVFolderComparator {

    private static final double TOLERANCE = 1.0; // Set tolerance threshold

    public static void main(String[] args) {
        String mainFolderPath = "C://main/";
        File mainFolder = new File(mainFolderPath);
        File[] setFolders = mainFolder.listFiles(File::isDirectory);

        if (setFolders == null || setFolders.length == 0) {
            System.out.println("No folders found in the main directory: " + mainFolderPath);
            return;
        }

        for (File setFolder : setFolders) {
            System.out.println("\nProcessing folder: " + setFolder.getName());
            processSetFolder(setFolder);
        }
    }

    private static void processSetFolder(File setFolder) {
        System.out.println("Reading row mismatch file...");
        Set<String> rowIds = readRows(setFolder);
        System.out.println("Total row IDs found: " + rowIds.size());

        System.out.println("Reading column mismatch file...");
        List<String> columns = readColumns(setFolder);
        System.out.println("Total columns found: " + columns.size());

        if (rowIds.isEmpty() || columns.isEmpty()) {
            System.out.println("Skipping folder " + setFolder.getName() + " (No row IDs or columns found)");
            return;
        }

        System.out.println("Reading actual CSV...");
        Map<String, Map<String, String>> actualData = readCSV(new File(setFolder, "actualoutputfile.csv"), rowIds, columns);
        System.out.println("Actual CSV read successfully. Total rows: " + actualData.size());

        System.out.println("Reading expected CSV...");
        Map<String, Map<String, String>> expectedData = readCSV(new File(setFolder, "expectedoutputfile.csv"), rowIds, columns);
        System.out.println("Expected CSV read successfully. Total rows: " + expectedData.size());

        List<String[]> differences = new ArrayList<>();
        Map<String, int[]> columnStats = new HashMap<>();

        columns.forEach(column -> columnStats.put(column, new int[2]));

        for (String rowId : rowIds) {
            Map<String, String> actualRow = actualData.getOrDefault(rowId, Collections.emptyMap());
            Map<String, String> expectedRow = expectedData.getOrDefault(rowId, Collections.emptyMap());

            for (String column : columns) {
                int[] stats = columnStats.get(column);
                stats[1]++; // Total comparisons

                String actualValue = actualRow.get(column);
                String expectedValue = expectedRow.get(column);

                if (!areValuesEqual(actualValue, expectedValue)) {
                    differences.add(new String[]{rowId, column, formatValue(actualValue), formatValue(expectedValue)});
                    stats[0]++;
                }
            }
        }

        System.out.println("Total Differences Found: " + differences.size());

        System.out.println("Writing differences to file...");
        writeDifferences(setFolder, differences);
        System.out.println("Differences written successfully.");

        System.out.println("Writing summary report...");
        writeSummaryReport(setFolder, columnStats, rowIds.size());
        System.out.println("Summary report written successfully.");

        System.out.println("Finished processing folder: " + setFolder.getName());
    }

    private static Set<String> readRows(File setFolder) {
        File file = new File(setFolder, "rowmismatch.txt");
        if (!file.exists()) {
            System.out.println("File not found: " + file.getAbsolutePath());
            return Collections.emptySet();
        }

        try {
            return Files.lines(file.toPath())
                    .map(String::trim)
                    .filter(s -> !s.isEmpty())
                    .collect(Collectors.toSet());
        } catch (IOException e) {
            System.out.println("Error reading row mismatch file: " + e.getMessage());
            return Collections.emptySet();
        }
    }

    private static List<String> readColumns(File setFolder) {
        File file = new File(setFolder, "columnstocomparemismatch.txt");
        if (!file.exists()) {
            System.out.println("File not found: " + file.getAbsolutePath());
            return Collections.emptyList();
        }

        try {
            return Files.lines(file.toPath())
                    .map(String::trim)
                    .filter(s -> !s.isEmpty())
                    .collect(Collectors.toList());
        } catch (IOException e) {
            System.out.println("Error reading column mismatch file: " + e.getMessage());
            return Collections.emptyList();
        }
    }

    private static void writeDifferences(File setFolder, List<String[]> differences) {
        File diffFile = new File(setFolder, "differences.csv");

        try (PrintWriter writer = new PrintWriter(new FileWriter(diffFile))) {
            writer.println("SubjectID,Column,Actual,Expected");
            for (String[] diff : differences) {
                writer.println(String.join(",", diff));
            }
        } catch (IOException e) {
            System.out.println("Error writing differences file: " + e.getMessage());
        }
    }

    private static void writeSummaryReport(File setFolder, Map<String, int[]> columnStats, int totalRows) {
        File reportFile = new File(setFolder, "summary_report.txt");

        try (PrintWriter writer = new PrintWriter(new FileWriter(reportFile))) {
            writer.println("Total number of rowIDs to consider for mismatch: " + totalRows);
            writer.println("Column Name and Percentage of Mismatch:");

            for (Map.Entry<String, int[]> entry : columnStats.entrySet()) {
                int[] stats = entry.getValue();
                double percentage = (stats[0] * 100.0) / stats[1];
                writer.printf("%s: %d out of %d (%.2f%%)\n", entry.getKey(), stats[0], stats[1], percentage);
            }
        } catch (IOException e) {
            System.out.println("Error writing summary report: " + e.getMessage());
        }
    }

    private static boolean areValuesEqual(String actual, String expected) {
        boolean actualIsEmpty = (actual == null || actual.trim().isEmpty());
        boolean expectedIsEmpty = (expected == null || expected.trim().isEmpty());

        if (expectedIsEmpty) {
            return true;
        }
        if (actualIsEmpty) {
            return false;
        }

        try {
            BigDecimal actualNum = new BigDecimal(actual.trim()).setScale(5, RoundingMode.HALF_UP);
            BigDecimal expectedNum = new BigDecimal(expected.trim()).setScale(5, RoundingMode.HALF_UP);
            return actualNum.subtract(expectedNum).compareTo(BigDecimal.valueOf(TOLERANCE)) <= 0;
        } catch (NumberFormatException e) {
            return actual.trim().equalsIgnoreCase(expected.trim());
        }
    }

    private static String formatValue(String value) {
        if (value == null || value.trim().isEmpty() || value.equalsIgnoreCase("null")) {
            return "MISSING";
        }
        try {
            BigDecimal number = new BigDecimal(value.trim()).setScale(5, RoundingMode.HALF_UP);
            return number.stripTrailingZeros().toPlainString();
        } catch (NumberFormatException e) {
            return value.trim();
        }
    }
}
