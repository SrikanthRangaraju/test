import java.io.*;
import java.nio.file.*;
import java.text.Normalizer;
import java.util.*;
import java.util.stream.Collectors;

public class CSVFolderComparator {

    public static void main(String[] args) throws Exception {
        String mainFolderPath = "main"; // Path to the main folder
        File mainFolder = new File(mainFolderPath);

        if (!mainFolder.exists() || !mainFolder.isDirectory()) {
            throw new IllegalArgumentException("Invalid main folder path");
        }

        for (File setFolder : Objects.requireNonNull(mainFolder.listFiles(File::isDirectory))) {
            System.out.println("Processing folder: " + setFolder.getName());
            processSetFolder(setFolder);
        }
    }

    private static void processSetFolder(File setFolder) throws Exception {
        File actualFile = new File(setFolder, "actualoutputfile.csv");
        File expectedFile = new File(setFolder, "expectedoutputfile.csv");
        File columnFile = new File(setFolder, "columnstobeconsiderformismatch.txt");
        File rowFile = new File(setFolder, "rowidstobeconsiderformismatch.txt");

        if (!actualFile.exists() || !expectedFile.exists() || !columnFile.exists() || !rowFile.exists()) {
            throw new IllegalArgumentException("Missing required files in folder: " + setFolder.getName());
        }

        List<String> actualLines = Files.readAllLines(actualFile.toPath());
        List<String> expectedLines = Files.readAllLines(expectedFile.toPath());
        Set<String> columnsToConsider = new HashSet<>(Files.readAllLines(columnFile.toPath()));
        Set<String> rowsToConsider = new HashSet<>(Files.readAllLines(rowFile.toPath()));

        Map<String, Integer> actualHeaderMap = createHeaderMap(actualLines.get(0));
        Map<String, Integer> expectedHeaderMap = createHeaderMap(expectedLines.get(0));

        List<String[]> actualData = parseData(actualLines, actualHeaderMap);
        List<String[]> expectedData = parseData(expectedLines, expectedHeaderMap);

        Map<String, String[]> actualRows = filterRowsById(actualData, actualHeaderMap.get("SubjectId"), rowsToConsider);
        Map<String, String[]> expectedRows = filterRowsById(expectedData, expectedHeaderMap.get("SubjectId"), rowsToConsider);

        List<String> diffOutput = new ArrayList<>();
        List<String> matchOutput = new ArrayList<>();
        diffOutput.add(String.join(",", "SubjectId", "Column", "ActualValue", "ExpectedValue"));
        matchOutput.add(String.join(",", "SubjectId", "Column", "MatchedValue", "ActualValue", "ExpectedValue"));

        Map<String, Integer> matchSummary = new HashMap<>();

        for (String subjectId : actualRows.keySet()) {
            if (!expectedRows.containsKey(subjectId)) continue;

            String[] actualRow = actualRows.get(subjectId);
            String[] expectedRow = expectedRows.get(subjectId);

            for (String column : columnsToConsider) {
                int actualIndex = actualHeaderMap.getOrDefault(column.toLowerCase(), -1);
                int expectedIndex = expectedHeaderMap.getOrDefault(column.toLowerCase(), -1);

                if (actualIndex == -1 || expectedIndex == -1) continue;

                String actualValue = normalizeString(actualRow[actualIndex]);
                String expectedValue = normalizeString(expectedRow[expectedIndex]);

                if (!areValuesEqual(actualValue, expectedValue)) {
                    diffOutput.add(String.join(",", subjectId, column, actualValue, expectedValue));
                } else {
                    matchOutput.add(String.join(",", subjectId, column, actualValue, actualValue, expectedValue));
                }

                int matchPercentage = calculateMatchPercentage(actualValue, expectedValue);
                matchSummary.put(column, matchSummary.getOrDefault(column, 0) + matchPercentage);
            }
        }

        writeOutput(new File(setFolder, "difference.csv"), diffOutput);
        writeOutput(new File(setFolder, "matcheddata.csv"), matchOutput);
        writeSummaryReport(setFolder, matchSummary, rowsToConsider.size());
    }

    private static Map<String, Integer> createHeaderMap(String headerLine) {
        String[] headers = headerLine.split(",");
        Map<String, Integer> headerMap = new HashMap<>();
        for (int i = 0; i < headers.length; i++) {
            headerMap.put(headers[i].toLowerCase(), i);
        }
        return headerMap;
    }

    private static List<String[]> parseData(List<String> lines, Map<String, Integer> headerMap) {
        return lines.stream().skip(1).map(line -> line.split(",")).filter(row -> row.length == headerMap.size()).collect(Collectors.toList());
    }

    private static Map<String, String[]> filterRowsById(List<String[]> data, int idIndex, Set<String> rowIds) {
        return data.stream()
                .filter(row -> rowIds.contains(row[idIndex]))
                .collect(Collectors.toMap(row -> row[idIndex], row -> row));
    }

    private static String normalizeString(String input) {
        return Normalizer.normalize(input, Normalizer.Form.NFD)
                .replaceAll("\\p{M}", "")  // Remove diacritical marks
                .trim()
                .toLowerCase();
    }

    private static boolean areValuesEqual(String actual, String expected) {
        try {
            double actualNumber = Math.round(Double.parseDouble(actual));
            double expectedNumber = Math.round(Double.parseDouble(expected));
            return actualNumber == expectedNumber;
        } catch (NumberFormatException e) {
            return actual.equals(expected);
        }
    }

    private static int calculateMatchPercentage(String actual, String expected) {
        int maxLength = Math.max(actual.length(), expected.length());
        int distance = levenshteinDistance(actual, expected);
        return (int) ((1 - ((double) distance / maxLength)) * 100);
    }

    private static int levenshteinDistance(String str1, String str2) {
        int[][] dp = new int[str1.length() + 1][str2.length() + 1];

        for (int i = 0; i <= str1.length(); i++) {
            for (int j = 0; j <= str2.length(); j++) {
                if (i == 0) {
                    dp[i][j] = j;
                } else if (j == 0) {
                    dp[i][j] = i;
                } else {
                    dp[i][j] = Math.min(
                            Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1),
                            dp[i - 1][j - 1] + (str1.charAt(i - 1) == str2.charAt(j - 1) ? 0 : 1)
                    );
                }
            }
        }

        return dp[str1.length()][str2.length()];
    }

    private static void writeOutput(File outputFile, List<String> lines) throws IOException {
        Files.write(outputFile.toPath(), lines);
    }

    private static void writeSummaryReport(File folder, Map<String, Integer> matchSummary, int totalRows) throws IOException {
        List<String> summary = new ArrayList<>();
        summary.add("Total number of rows considered: " + totalRows);
        summary.add("Column Name : Match Percentage");

        matchSummary.entrySet().stream()
                .sorted(Map.Entry.comparingByKey())
                .forEach(entry -> summary.add(entry.getKey() + ": " + (entry.getValue() / totalRows) + "%"));

        writeOutput(new File(folder, "summary.txt"), summary);
    }
}
