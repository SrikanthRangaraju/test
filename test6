import java.io.*;
import java.nio.file.*;
import java.text.Normalizer;
import java.util.*;
import java.util.stream.Collectors;

public class CSVFolderComparator {

    public static void main(String[] args) throws Exception {
        String mainFolderPath = "main"; // Path to the main folder
        File mainFolder = new File(mainFolderPath);

        if (!mainFolder.exists() || !mainFolder.isDirectory()) {
            throw new IllegalArgumentException("Invalid main folder path");
        }

        for (File setFolder : Objects.requireNonNull(mainFolder.listFiles(File::isDirectory))) {
            System.out.println("Processing folder: " + setFolder.getName());
            processSetFolder(setFolder);
        }
    }

    private static void processSetFolder(File setFolder) throws Exception {
        File actualFile = new File(setFolder, "actualoutputfile.csv");
        File expectedFile = new File(setFolder, "expectedoutputfile.csv");
        File columnFile = new File(setFolder, "columnstobeconsiderformismatch.txt");
        File rowFile = new File(setFolder, "rowidstobeconsiderformismatch.txt");

        if (!actualFile.exists() || !expectedFile.exists() || !columnFile.exists() || !rowFile.exists()) {
            throw new IllegalArgumentException("Missing required files in folder: " + setFolder.getName());
        }

        List<String> actualLines = Files.readAllLines(actualFile.toPath());
        List<String> expectedLines = Files.readAllLines(expectedFile.toPath());
        Set<String> columnsToConsider = new HashSet<>(Files.readAllLines(columnFile.toPath()));
        Set<String> rowsToConsider = new HashSet<>(Files.readAllLines(rowFile.toPath()));

        Map<String, Integer> actualHeaderMap = createHeaderMap(actualLines.get(0));
        Map<String, Integer> expectedHeaderMap = createHeaderMap(expectedLines.get(0));

        // Parse data and align rows by SubjectId
        Map<String, String[]> actualData = alignRowsById(parseData(actualLines, actualHeaderMap), actualHeaderMap.get("subjectid"));
        Map<String, String[]> expectedData = alignRowsById(parseData(expectedLines, expectedHeaderMap), expectedHeaderMap.get("subjectid"));

        List<String> diffOutput = new ArrayList<>();
        List<String> matchOutput = new ArrayList<>();
        diffOutput.add(String.join(",", "SubjectId", "Column", "ActualValue", "ExpectedValue"));
        matchOutput.add(String.join(",", "SubjectId", "Column", "MatchedValue", "ActualValue", "ExpectedValue"));

        Map<String, Integer> matchCounts = new HashMap<>();
        Map<String, Integer> totalCounts = new HashMap<>();

        for (String subjectId : rowsToConsider) {
            if (!actualData.containsKey(subjectId) || !expectedData.containsKey(subjectId)) continue;

            String[] actualRow = actualData.get(subjectId);
            String[] expectedRow = expectedData.get(subjectId);

            for (String column : columnsToConsider) {
                Integer actualIndex = actualHeaderMap.get(column.toLowerCase());
                Integer expectedIndex = expectedHeaderMap.get(column.toLowerCase());

                if (actualIndex == null || expectedIndex == null) continue;

                String actualValue = normalizeString(actualRow[actualIndex]);
                String expectedValue = normalizeString(expectedRow[expectedIndex]);

                totalCounts.put(column, totalCounts.getOrDefault(column, 0) + 1);

                if (!areValuesEqual(actualValue, expectedValue)) {
                    diffOutput.add(String.join(",", subjectId, column, actualValue, expectedValue));
                } else {
                    matchOutput.add(String.join(",", subjectId, column, actualValue, actualValue, expectedValue));
                    matchCounts.put(column, matchCounts.getOrDefault(column, 0) + 1);
                }
            }
        }

        writeOutput(new File(setFolder, "difference.csv"), diffOutput);
        writeOutput(new File(setFolder, "matcheddata.csv"), matchOutput);
        writeSummaryReport(setFolder, matchCounts, totalCounts);
    }

    private static Map<String, Integer> createHeaderMap(String headerLine) {
        String[] headers = headerLine.split(",");
        Map<String, Integer> headerMap = new HashMap<>();
        for (int i = 0; i < headers.length; i++) {
            headerMap.put(headers[i].toLowerCase(), i);
        }
        return headerMap;
    }

    private static List<String[]> parseData(List<String> lines, Map<String, Integer> headerMap) {
        return lines.stream().skip(1).map(line -> line.split(",")).collect(Collectors.toList());
    }

    private static Map<String, String[]> alignRowsById(List<String[]> rows, int idIndex) {
        return rows.stream().collect(Collectors.toMap(row -> row[idIndex], row -> row));
    }

    private static String normalizeString(String input) {
        return Normalizer.normalize(input, Normalizer.Form.NFD)
                .replaceAll("\\p{M}", "") // Remove diacritical marks
                .trim()
                .toLowerCase();
    }

    private static boolean areValuesEqual(String actual, String expected) {
        try {
            double actualNumber = Math.round(Double.parseDouble(actual));
            double expectedNumber = Math.round(Double.parseDouble(expected));
            return actualNumber == expectedNumber;
        } catch (NumberFormatException e) {
            return actual.equals(expected);
        }
    }

    private static void writeOutput(File outputFile, List<String> lines) throws IOException {
        Files.write(outputFile.toPath(), lines);
    }

    private static void writeSummaryReport(File folder, Map<String, Integer> matchCounts, Map<String, Integer> totalCounts) throws IOException {
        List<String> summary = new ArrayList<>();
        summary.add("Total number of rows considered: " + totalCounts.values().stream().mapToInt(Integer::intValue).sum());
        summary.add("Column Name : Match Percentage");

        totalCounts.keySet().stream().sorted()
                .forEach(column -> {
                    int matches = matchCounts.getOrDefault(column, 0);
                    int total = totalCounts.getOrDefault(column, 0);
                    summary.add(column + ": " + (matches * 100 / total) + "%");
                });

        writeOutput(new File(folder, "summary.txt"), summary);
    }
}
