import com.opencsv.CSVReader;
import com.opencsv.CSVWriter;
import java.io.*;
import java.util.*;
import java.util.stream.Collectors;

public class CSVComparator {
    private static final String SUBJECT_ID = "subjectid";

    public static void main(String[] args) {
        String file1Path = "file1.csv";
        String file2Path = "file2.csv";
        String diffPath = "differences.csv";
        String reportPath = "summary_report.txt";

        try {
            CsvData csvData1 = readCsv(file1Path);
            CsvData csvData2 = readCsv(file2Path);
            Set<String> commonColumns = getCommonColumnsCaseInsensitive(csvData1, csvData2);
            Map<String, int[]> columnStats = new HashMap<>();

            // Preserve order: File1 subjects first, then File2 subjects (excluding duplicates)
            List<String> orderedSubjects = new ArrayList<>(csvData1.subjectOrder);
            for (String subject : csvData2.subjectOrder) {
                if (!orderedSubjects.contains(subject)) {
                    orderedSubjects.add(subject);
                }
            }

            try (CSVWriter diffWriter = new CSVWriter(new FileWriter(diffPath))) {
                diffWriter.writeNext(new String[]{"SUBJECTID", "COLUMN_NAME", "FILE1_VALUE", "FILE2_VALUE"});

                for (String subject : orderedSubjects) {
                    Map<String, String> row1 = csvData1.data.get(subject);
                    Map<String, String> row2 = csvData2.data.get(subject);

                    if (row1 == null || row2 == null) {
                        System.out.println("Subject ID " + subject + " missing in one file");
                        continue;
                    }

                    for (String lowerCol : commonColumns) {
                        String col1 = csvData1.columnMappings.get(lowerCol);
                        String col2 = csvData2.columnMappings.get(lowerCol);

                        String value1 = row1.getOrDefault(col1, "MISSING");
                        String value2 = row2.getOrDefault(col2, "MISSING");

                        int[] counts = columnStats.computeIfAbsent(col1, k -> new int[2]);
                        counts[1]++;

                        if (!value1.equals(value2)) {
                            diffWriter.writeNext(new String[]{subject, col1, value1, value2});
                        } else {
                            counts[0]++;
                        }
                    }
                }
            }

            // [Keep the existing summary report generation code unchanged]
            
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private static CsvData readCsv(String filePath) throws Exception {
        Map<String, Map<String, String>> data = new LinkedHashMap<>(); // Preserves insertion order
        Map<String, String> columnMappings = new HashMap<>();
        List<String> subjectOrder = new ArrayList<>();

        try (CSVReader reader = new CSVReader(new FileReader(filePath))) {
            String[] headers = reader.readNext();
            if (headers == null) return new CsvData(data, columnMappings, subjectOrder);

            // Create column mappings
            for (String header : headers) {
                String cleanHeader = header.trim();
                String lowerHeader = cleanHeader.toLowerCase();
                columnMappings.put(lowerHeader, cleanHeader);
            }

            String[] row;
            while ((row = reader.readNext()) != null) {
                String subjectId = row[0].trim();
                subjectOrder.add(subjectId); // Track order of appearance
                Map<String, String> rowMap = new HashMap<>();

                for (int i = 0; i < headers.length; i++) {
                    String header = headers[i].trim();
                    String value = i < row.length ? row[i].trim() : "";
                    rowMap.put(header, value);
                }

                data.put(subjectId, rowMap);
            }
        }
        return new CsvData(data, columnMappings, subjectOrder);
    }

    static class CsvData {
        Map<String, Map<String, String>> data;
        Map<String, String> columnMappings;
        List<String> subjectOrder;

        CsvData(Map<String, Map<String, String>> data, 
                Map<String, String> columnMappings,
                List<String> subjectOrder) {
            this.data = data;
            this.columnMappings = columnMappings;
            this.subjectOrder = subjectOrder;
        }
    }

    // [Keep other helper methods unchanged]
}
